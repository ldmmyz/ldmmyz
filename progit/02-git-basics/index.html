<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Pro Git - 2. Git 基础 | 灵动</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="Pro Git,git,灵动计算机社,茂名市第一中学灵动计算机社,灵动,计算机技术,茂名市第一中学社团联合会">
  <meta content="website" property="og:type">
<meta content="Pro Git - 2. Git 基础" property="og:title">
<meta content="http://ld.mmyz.net/progit/02-git-basics/index.html" property="og:url">
<meta content="http://git-scm.com/figures/18333fig0201-tn.png" property="og:image">
<meta content="灵动" property="og:site_name">
<meta content="读完本章你就能上手使用 Git 了。本章将介绍几个最基本的，也是最常用的 Git 命令，以后绝大多数时间里用到的也就是这几个命令。读完本章，你就能初始化一个新的代码仓库，做一些适当配置；开始或停止跟踪某些文件；暂存或提交某些更新。我们还会展示如何让 Git 忽略某些文件，或是名称符合特定模式的文件；如何既快且容易地撤消犯下的小错误；如何浏览项目的更新历史，查看某两次更新之间的差异；以及如何从远程仓" property="og:description">
<meta content="summary" name="twitter:card">
  
    <link rel="alternative" href="/atom.xml" title="灵动" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link href="/css/source_code_pro.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
  
    <script type="text/javascript">
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?9fd77bbfdc55eb614a76ca1c016b0217";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">灵动</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">茂名市第一中学灵动计算机社</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
          <a class="main-nav-link" href="/archives">存档</a>
        
          <a class="main-nav-link" href="http://www.mmyz.net/">学校网站</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="submit" value="&#xF002;" class="search-form-submit"><input type="hidden" name="q" value="site:http://ld.mmyz.net"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="page-undefined" class="article article-type-page" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/progit/02-git-basics/index.html" class="article-date">
  <time datetime="2014-06-07T00:00:00.000Z" itemprop="datePublished">6月 7 2014</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Pro Git - 2. Git 基础
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>读完本章你就能上手使用 Git 了。本章将介绍几个最基本的，也是最常用的 Git 命令，以后绝大多数时间里用到的也就是这几个命令。读完本章，你就能初始化一个新的代码仓库，做一些适当配置；开始或停止跟踪某些文件；暂存或提交某些更新。我们还会展示如何让 Git 忽略某些文件，或是名称符合特定模式的文件；如何既快且容易地撤消犯下的小错误；如何浏览项目的更新历史，查看某两次更新之间的差异；以及如何从远程仓库拉数据下来或者推数据上去。</p>
<hr>
<h2 id="取得项目的_Git_仓库">取得项目的 Git 仓库</h2>
<p>有两种取得 Git 项目仓库的方法。第一种是在现存的目录下，通过导入所有文件来创建新的 Git 仓库。第二种是从已有的 Git 仓库克隆出一个新的镜像仓库来。</p>
<h3 id="在工作目录中初始化新仓库">在工作目录中初始化新仓库</h3>
<p>要对现有的某个项目开始用 Git 管理，只需到此项目所在的目录，执行：</p>
<pre><code><span class="variable">$ </span>git init
</code></pre><p>初始化后，在当前目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。不过目前，仅仅是按照既有的结构框架初始化好了里边所有的文件和目录，但我们还没有开始跟踪管理项目中的任何一个文件。（在第九章我们会详细说明刚才创建的 <code>.git</code> 目录中究竟有哪些文件，以及都起些什么作用。）</p>
<p>如果当前目录下有几个文件想要纳入版本控制，需要先用 <code>git add</code> 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p>
<pre><code><span class="variable">$ </span>git add *.c
<span class="variable">$ </span>git add <span class="constant">README</span>
<span class="variable">$ </span>git commit -m <span class="string">'initial project version'</span>
</code></pre><p>稍后我们再逐一解释每条命令的意思。不过现在，你已经得到了一个实际维护着若干文件的 Git 仓库。</p>
<h3 id="从现有仓库克隆">从现有仓库克隆</h3>
<p>如果想对某个开源项目出一份力，可以先把该项目的 Git 仓库复制一份出来，这就需要用到 <code>git clone</code> 命令。如果你熟悉其他的 VCS 比如 Subversion，你可能已经注意到这里使用的是 <code>clone</code> 而不是 <code>checkout</code>。这是个非常重要的差别，Git 收取的是项目历史的所有数据（每一个文件的每一个版本），服务器上有的数据克隆之后本地也都有了。实际上，即便服务器的磁盘发生故障，用任何一个克隆出来的客户端都可以重建服务器上的仓库，回到当初克隆时的状态（虽然可能会丢失某些服务器端的挂钩设置，但所有版本的数据仍旧还在，有关细节请参考第四章）。</p>
<p>克隆仓库的命令格式为 <code>git clone [url]</code>。比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p>
<pre><code><span class="variable">$ </span>git clone <span class="symbol">git:</span>/<span class="regexp">/github.com/schacon</span><span class="regexp">/grit.git</span>
</code></pre><p>这会在当前目录下创建一个名为<code>grit</code>的目录，其中包含一个 <code>.git</code> 的目录，用于保存下载下来的所有版本记录，然后从中取出最新版本的文件拷贝。如果进入这个新建的 <code>grit</code> 目录，你会看到项目中的所有文件已经在里边了，准备好后续的开发和使用。如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p>
<pre><code><span class="variable">$ </span>git clone <span class="symbol">git:</span>/<span class="regexp">/github.com/schacon</span><span class="regexp">/grit.git mygrit</span>
</code></pre><p>唯一的差别就是，现在新建的目录成了 <code>mygrit</code>，其他的都和上边的一样。</p>
<p>Git 支持许多数据传输协议。之前的例子使用的是 <code>git://</code> 协议，不过你也可以用 <code>http(s)://</code> 或者 <code>user@server:/path.git</code> 表示的 SSH 传输协议。我们会在第四章详细介绍所有这些协议在服务器端该如何配置使用，以及各种方式之间的利弊。</p>
<hr>
<h2 id="记录每次更新到仓库">记录每次更新到仓库</h2>
<p>现在我们手上已经有了一个真实项目的 Git 仓库，并从这个仓库中取出了所有文件的工作拷贝。接下来，对这些文件作些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。</p>
<p>请记住，工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的所有文件都属于已跟踪文件，且状态为未修改。</p>
<p>在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。所以使用 Git 时的文件状态变化周期如图 2-1 所示。</p>
<p><img src="http://git-scm.com/figures/18333fig0201-tn.png" alt="图 2-1. 文件的状态变化周期"></p>
<h3 id="检查当前文件状态">检查当前文件状态</h3>
<p>要确定哪些文件当前处于什么状态，可以用 <code>git status</code> 命令。如果在克隆仓库之后立即执行此命令，会看到类似这样的输出：</p>
<pre><code>$ git status
<span class="keyword">On</span> branch master
<span class="literal">nothing</span> <span class="keyword">to</span> commit, working directory clean
</code></pre><p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪的新文件，否则 Git 会在这里列出来。最后，该命令还显示了当前所在的分支是 <code>master</code>，这是默认的分支名称，实际是可以修改的，现在先不用考虑。下一章我们就会详细讨论分支和引用。</p>
<p>现在让我们用 vim 创建一个新文件 README，保存退出后运行 <code>git status</code> 会看到该文件出现在未跟踪文件列表中：</p>
<pre><code>$ vim README
$ git status
On branch master
Untracked <span class="built_in">files</span>:
  (use <span class="string">"git add &lt;file&gt;..."</span> <span class="built_in">to</span> <span class="built_in">include</span> <span class="operator">in</span> what will be committed)

        README

nothing added <span class="built_in">to</span> commit but untracked <span class="built_in">files</span> present (use <span class="string">"git add"</span> <span class="built_in">to</span> track)
</code></pre><p>在状态报告中可以看到新建的<code>README</code>文件出现在“Untracked files”下面。未跟踪的文件意味着Git在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”，因而不用担心把临时文件什么的也归入版本管理。不过现在的例子中，我们确实想要跟踪管理 README 这个文件。</p>
<h3 id="跟踪新文件">跟踪新文件</h3>
<p>使用命令 <code>git add</code> 开始跟踪一个新文件。所以，要跟踪 README 文件，运行：</p>
<pre><code><span class="variable">$ </span>git add <span class="constant">README</span>
</code></pre><p>此时再运行 <code>git status</code> 命令，会看到 README 文件已被跟踪，并处于暂存状态：</p>
<pre><code>$ git status
<span class="keyword">On</span> branch master
Changes <span class="keyword">to</span> be committed:
  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)

        <span class="keyword">new</span> <span class="keyword">file</span>:   README
</code></pre><p>只要在 “Changes to be committed” 这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。你可能会想起之前我们使用 <code>git init</code> 后就运行了 <code>git add</code> 命令，开始跟踪当前目录下的文件。在 <code>git add</code> 后面可以指明要跟踪的文件或目录路径。如果是目录的话，就说明要递归跟踪该目录下的所有文件。（译注：其实 <code>git add</code> 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同时未曾跟踪过的文件标记为需要跟踪。这样就好理解后续 add 操作的实际意义了。）</p>
<h3 id="暂存已修改文件">暂存已修改文件</h3>
<p>现在我们修改下之前已跟踪过的文件 <code>benchmarks.rb</code>，然后再次运行 <code>status</code> 命令，会看到这样的状态报告：</p>
<pre><code>$ git status
<span class="keyword">On</span> branch master
Changes <span class="keyword">to</span> be committed:
  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)

        <span class="keyword">new</span> <span class="keyword">file</span>:   README

Changes <span class="keyword">not</span> staged <span class="keyword">for</span> commit:
  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> update what will be committed)
  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working directory)

        modified:   benchmarks.rb
</code></pre><p>文件 <code>benchmarks.rb</code> 出现在 “Changes not staged for commit” 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行 <code>git add</code> 命令（这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等）。现在让我们运行 <code>git add</code> 将 benchmarks.rb 放到暂存区，然后再看看 <code>git status</code> 的输出：</p>
<pre><code>$ git add benchmarks.rb
$ git status
<span class="keyword">On</span> branch master
Changes <span class="keyword">to</span> be committed:
  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)

        <span class="keyword">new</span> <span class="keyword">file</span>:   README
        modified:   benchmarks.rb
</code></pre><p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。假设此时，你想要在 <code>benchmarks.rb</code> 里再加条注释，重新编辑存盘后，准备好提交。不过且慢，再运行 <code>git status</code> 看看：</p>
<pre><code>$ vim benchmarks.rb
$ git status
<span class="keyword">On</span> branch master
Changes <span class="keyword">to</span> be committed:
  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)

        <span class="keyword">new</span> <span class="keyword">file</span>:   README
        modified:   benchmarks.rb

Changes <span class="keyword">not</span> staged <span class="keyword">for</span> commit:
  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> update what will be committed)
  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working directory)

        modified:   benchmarks.rb
</code></pre><p>怎么回事？ <code>benchmarks.rb</code> 文件出现了两次！一次算未暂存，一次算已暂存，这怎么可能呢？好吧，实际上 Git 只不过暂存了你运行 <code>git add</code> 命令时的版本，如果现在提交，那么提交的是添加注释前的版本，而非当前工作目录中的版本。所以，运行了 <code>git add</code> 之后又作了修订的文件，需要重新运行 <code>git add</code> 把最新版本重新暂存起来：</p>
<pre><code>$ git add benchmarks.rb
$ git status
<span class="keyword">On</span> branch master
Changes <span class="keyword">to</span> be committed:
  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)

        <span class="keyword">new</span> <span class="keyword">file</span>:   README
        modified:   benchmarks.rb
</code></pre><h3 id="忽略某些文件">忽略某些文件</h3>
<p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式。来看一个实际的例子：</p>
<pre><code><span class="variable">$ </span>cat .gitignore
*.[oa]
*~
</code></pre><p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的，我们用不着跟踪它们的版本。第二行告诉 Git 忽略所有以波浪符（<code>~</code>）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。此外，你可能还需要忽略 <code>log</code>，<code>tmp</code> 或者 <code>pid</code> 目录，以及自动生成的文档等等。要养成一开始就设置好 <code>.gitignore</code> 文件的习惯，以免将来误提交这类无用的文件。</p>
<p>文件 <code>.gitignore</code> 的格式规范如下：</p>
<ul>
<li>所有空行或者以注释符号 <code>＃</code> 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式最后跟反斜杠（<code>/</code>）说明要忽略的是目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（<code>!</code>）取反。</li>
</ul>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（<code>*</code>）匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）；问号（<code>?</code>）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 <code>[0-9]</code> 表示匹配所有 0 到 9 的数字）。</p>
<p>我们再看一个 <code>.gitignore</code> 文件的例子：</p>
<pre><code><span class="preprocessor"># 此为注释 – 将被 Git 忽略</span>
<span class="preprocessor"># 忽略所有 .a 结尾的文件</span>
*.a
<span class="preprocessor"># 但 lib.a 除外</span>
!lib.a
<span class="preprocessor"># 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span>
/TODO
<span class="preprocessor"># 忽略 build/ 目录下的所有文件</span>
build/
<span class="preprocessor"># 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span>
doc<span class="comment">/*.txt
# ignore all .txt files in the doc/ directory
doc/**/</span>*.txt
</code></pre><p>A <code>**/</code> pattern is available in Git since version 1.8.2.</p>
<h3 id="查看已暂存和未暂存的更新">查看已暂存和未暂存的更新</h3>
<p>实际上 <code>git status</code> 的显示比较简单，仅仅是列出了修改过的文件，如果要查看具体修改了什么地方，可以用 <code>git diff</code> 命令。稍后我们会详细介绍 <code>git diff</code>，不过现在，它已经能回答我们的两个问题了：当前做的哪些更新还没有暂存？有哪些更新已经暂存起来准备好了下次提交？ <code>git diff</code> 会使用文件补丁的格式显示具体添加和删除的行。</p>
<p>假如再次修改 <code>README</code> 文件后暂存，然后编辑 <code>benchmarks.rb</code> 文件后先别暂存，运行 <code>status</code> 命令将会看到：</p>
<pre><code>$ git status
<span class="keyword">On</span> branch master
Changes <span class="keyword">to</span> be committed:
  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)

        <span class="keyword">new</span> <span class="keyword">file</span>:   README

Changes <span class="keyword">not</span> staged <span class="keyword">for</span> commit:
  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> update what will be committed)
  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working directory)

        modified:   benchmarks.rb
</code></pre><p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code>：</p>
<pre><code>$ git diff
diff <span class="comment">--git a/benchmarks.rb b/benchmarks.rb</span>
index <span class="number">3</span>cb747f..da65585 <span class="number">100644</span>
<span class="comment">--- a/benchmarks.rb</span>
+++ b/benchmarks.rb
@@ -<span class="number">36</span>,<span class="number">6</span> +<span class="number">36</span>,<span class="number">10</span> @@ def main
           @commit.parents[<span class="number">0</span>].parents[<span class="number">0</span>].parents[<span class="number">0</span>]
         <span class="function"><span class="keyword">end</span></span>

+        run_code(x, <span class="string">'commits 1'</span>) <span class="built_in">do</span>
+          git.commits.size
+        <span class="function"><span class="keyword">end</span></span>
+
         run_code(x, <span class="string">'commits 2'</span>) <span class="built_in">do</span>
           <span class="built_in">log</span> = git.commits(<span class="string">'master'</span>, <span class="number">15</span>)
           <span class="built_in">log</span>.size
</code></pre><p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。</p>
<p>若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 <code>git diff --cached</code> 命令。（Git 1.6.1 及更高版本还允许使用 <code>git diff --staged</code>，效果是相同的，但更好记些。）来看看实际的效果：</p>
<pre><code>$ git diff --cached
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
<span class="header">--- /dev/null</span>
<span class="header">+++ b/README2</span>
<span class="chunk">@@ -0,0 +1,5 @@</span>
<span class="addition">+grit</span>
<span class="addition">+ by Tom Preston-Werner, Chris Wanstrath</span>
<span class="addition">+ http://github.com/mojombo/grit</span>
<span class="addition">+</span>
<span class="addition">+Grit is a Ruby library for extracting information from a Git repository</span>
</code></pre><p>请注意，单单 <code>git diff</code> 不过是显示还没有暂存起来的改动，而不是这次工作和上次提交之间的差异。所以有时候你一下子暂存了所有更新过的文件后，运行 <code>git diff</code> 后却什么也没有，就是这个原因。</p>
<p>像之前说的，暂存 benchmarks.rb 后再编辑，运行 <code>git status</code> 会看到暂存前后的两个版本：</p>
<pre><code>$ git add benchmarks.rb
$ echo '# test line' &gt;&gt; benchmarks.rb
$ git status
<span class="keyword">On</span> branch master
Changes <span class="keyword">to</span> be committed:
  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)

        modified:   benchmarks.rb

Changes <span class="keyword">not</span> staged <span class="keyword">for</span> commit:
  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> update what will be committed)
  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working directory)

        modified:   benchmarks.rb
</code></pre><p>现在运行 <code>git diff</code> 看暂存前后的变化：</p>
<pre><code>$ git diff
diff <span class="comment">--git a/benchmarks.rb b/benchmarks.rb</span>
index e445e28.<span class="number">.86</span>b2f7c <span class="number">100644</span>
<span class="comment">--- a/benchmarks.rb</span>
+++ b/benchmarks.rb
@@ -<span class="number">127</span>,<span class="number">3</span> +<span class="number">127</span>,<span class="number">4</span> @@ <span class="function"><span class="keyword">end</span></span>
 main()

 <span class="comment">##pp Grit::GitRuby.cache_client.stats</span>
+<span class="comment"># test line</span>
</code></pre><p>然后用 <code>git diff --cached</code> 查看已经暂存起来的变化：</p>
<pre><code>$ git diff <span class="comment">--cached</span>
diff <span class="comment">--git a/benchmarks.rb b/benchmarks.rb</span>
index <span class="number">3</span>cb747f..e445e28 <span class="number">100644</span>
<span class="comment">--- a/benchmarks.rb</span>
+++ b/benchmarks.rb
@@ -<span class="number">36</span>,<span class="number">6</span> +<span class="number">36</span>,<span class="number">10</span> @@ def main
          @commit.parents[<span class="number">0</span>].parents[<span class="number">0</span>].parents[<span class="number">0</span>]
        <span class="function"><span class="keyword">end</span></span>

+        run_code(x, <span class="string">'commits 1'</span>) <span class="built_in">do</span>
+          git.commits.size
+        <span class="function"><span class="keyword">end</span></span>
+
        run_code(x, <span class="string">'commits 2'</span>) <span class="built_in">do</span>
          <span class="built_in">log</span> = git.commits(<span class="string">'master'</span>, <span class="number">15</span>)
          <span class="built_in">log</span>.size
</code></pre><h3 id="提交更新">提交更新</h3>
<p>现在的暂存区域已经准备妥当可以提交了。在此之前，请一定要确认还有什么修改过的或新建的文件还没有 <code>git add</code> 过，否则提交的时候不会记录这些还没暂存起来的变化。所以，每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了，然后再运行提交命令 <code>git commit</code>：</p>
<pre><code><span class="variable">$ </span>git commit
</code></pre><p>这种方式会启动文本编辑器以便输入本次提交的说明。（默认会启用 shell 的环境变量 <code>$EDITOR</code> 所指定的软件，一般都是 vim 或 emacs。当然也可以按照第一章介绍的方式，使用 <code>git config --global core.editor</code> 命令设定你喜欢的编辑软件。）</p>
<p>编辑器会显示类似下面的文本信息（本例选用 Vim 的屏显方式展示）：</p>
<pre><code><span class="preprocessor"># Please enter the commit message for your changes. Lines starting</span>
<span class="preprocessor"># with '#' will be ignored, and an empty message aborts the commit.</span>
<span class="preprocessor"># On branch master</span>
<span class="preprocessor"># Changes to be committed:</span>
<span class="preprocessor">#       new file:   README</span>
<span class="preprocessor">#       modified:   benchmarks.rb</span>
<span class="preprocessor">#</span>
~
~
~
<span class="string">".git/COMMIT_EDITMSG"</span> <span class="number">10</span>L, <span class="number">283</span>C
</code></pre><p>可以看到，默认的提交消息包含最后一次运行 <code>git status</code> 的输出，放在注释行里，另外开头还有一空行，供你输入提交说明。你完全可以去掉这些注释行，不过留着也没关系，多少能帮你回想起这次更新的内容有哪些。（如果觉得这还不够，可以用 <code>-v</code> 选项将修改差异的每一行都包含到注释中来。）退出编辑器时，Git 会丢掉注释行，将说明内容和本次更新提交到仓库。</p>
<p>另外也可以用 -m 参数后跟提交说明的方式，在一行命令中提交更新：</p>
<pre><code>$ git <span class="operator"><span class="keyword">commit</span> -m <span class="string">"Story 182: Fix benchmarks for speed"</span>
[master <span class="number">463</span>dc4f] Story <span class="number">182</span>: Fix benchmarks <span class="keyword">for</span> speed
 <span class="number">2</span> files changed, <span class="number">3</span> insertions(+)
 <span class="keyword">create</span> mode <span class="number">100644</span> README</span>
</code></pre><p>好，现在你已经创建了第一个提交！可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（<code>463dc4f</code>），以及在本次提交中，有多少文件修订过，多少行添改和删改过。</p>
<p>记住，提交时记录的是放在暂存区域的快照，任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。</p>
<h3 id="跳过使用暂存区域">跳过使用暂存区域</h3>
<p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式，只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤：</p>
<pre><code>$ git status
<span class="keyword">On</span> branch master
Changes <span class="keyword">not</span> staged <span class="keyword">for</span> commit:
  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> update what will be committed)
  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working directory)

        modified:   benchmarks.rb

no changes added <span class="keyword">to</span> commit (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)
$ git commit -a -m <span class="attribute">'added</span> <span class="keyword">new</span> benchmarks'
[master <span class="number">83e38</span>c7] added <span class="keyword">new</span> benchmarks
 <span class="number">1</span> files changed, <span class="number">5</span> insertions(+)
</code></pre><p>看到了吗？提交之前不再需要 <code>git add</code> 文件 benchmarks.rb 了。</p>
<h3 id="移除文件">移除文件</h3>
<p>要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 <code>git rm</code> 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>
<p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 “Changes not staged for commit” 部分（也就是<em>未暂存</em>清单）看到：</p>
<pre><code>$ rm grit.gemspec
$ git status
<span class="keyword">On</span> branch master
Changes <span class="keyword">not</span> staged <span class="keyword">for</span> commit:
  (<span class="keyword">use</span> <span class="string">"git add/rm &lt;file&gt;..."</span> <span class="keyword">to</span> update what will be committed)
  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working directory)

        deleted:    grit.gemspec

no changes added <span class="keyword">to</span> commit (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)
</code></pre><p>然后再运行 <code>git rm</code> 记录此次移除文件的操作：</p>
<pre><code>$ git rm grit.gemspec
rm <span class="attribute">'grit</span>.gemspec'
$ git status
<span class="keyword">On</span> branch master
Changes <span class="keyword">to</span> be committed:
  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)

        deleted:    grit.gemspec
</code></pre><p>最后提交的时候，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 <code>-f</code>（译注：即 force 的首字母），以防误删除文件后丢失修改的内容。</p>
<p>另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一堆 <code>.a</code> 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 <code>.gitignore</code> 文件中补上，用 <code>--cached</code> 选项即可：</p>
<pre><code><span class="comment">$</span> <span class="comment">git</span> <span class="comment">rm</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">cached</span> <span class="comment">readme</span><span class="string">.</span><span class="comment">txt</span>
</code></pre><p>后面可以列出文件或者目录的名字，也可以使用 glob 模式。比方说：</p>
<pre><code>$ git rm <span class="keyword">log</span>/\*.<span class="keyword">log</span>
</code></pre><p>注意到星号 <code>*</code> 之前的反斜杠 <code>\</code>，因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 shell 来帮忙展开（译注：实际上不加反斜杠也可以运行，只不过按照 shell 扩展的话，仅仅删除指定目录下的文件而不会递归匹配。上面的例子本来就指定了目录，所以效果等同，但下面的例子就会用递归方式匹配，所以必须加反斜杠。）。此命令删除所有 <code>log/</code> 目录下扩展名为 <code>.log</code> 的文件。类似的比如：</p>
<pre><code><span class="variable">$ </span>git rm \*~
</code></pre><p>会递归删除当前目录及其子目录中所有 <code>~</code> 结尾的文件。</p>
<h3 id="移动文件">移动文件</h3>
<p>不像其他的 VCS 系统，Git 并不跟踪文件移动操作。如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。不过 Git 非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。</p>
<p>既然如此，当你看到 Git 的 <code>mv</code> 命令时一定会困惑不已。要在 Git 中对文件改名，可以这么做：</p>
<pre><code><span class="variable">$ </span>git mv file_from file_to
</code></pre><p>它会恰如预期般正常工作。实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：</p>
<pre><code>$ git mv README.txt README
$ git status
<span class="keyword">On</span> branch master
Changes <span class="keyword">to</span> be committed:
  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)

        renamed:    README.txt -&gt; README
</code></pre><p>其实，运行 <code>git mv</code> 就相当于运行了下面三条命令：</p>
<pre><code><span class="variable">$ </span>mv <span class="constant">README</span>.txt <span class="constant">README</span>
<span class="variable">$ </span>git rm <span class="constant">README</span>.txt
<span class="variable">$ </span>git add <span class="constant">README</span>
</code></pre><p>如此分开操作，Git 也会意识到这是一次改名，所以不管何种方式都一样。当然，直接用 <code>git mv</code> 轻便得多，不过有时候用其他工具批处理改名的话，要记得在提交前删除老的文件名，再添加新的文件名。</p>
<hr>
<h2 id="查看提交历史">查看提交历史</h2>
<p>在提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，可以使用 <code>git log</code> 命令查看。</p>
<p>接下来的例子会用我专门用于演示的 simplegit 项目，运行下面的命令获取该项目源代码：</p>
<pre><code>git <span class="keyword">clone</span> git:<span class="comment">//github.com/schacon/simplegit-progit.git</span>
</code></pre><p>然后在此项目中运行 <code>git log</code>，应该会看到下面的输出：</p>
<pre><code>$ git log
<span class="operator"><span class="keyword">commit</span> ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
<span class="keyword">Date</span>:   Mon Mar <span class="number">17</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">11</span> <span class="number">2008</span> -<span class="number">0700</span>

    changed the version <span class="keyword">number</span>

<span class="keyword">commit</span> <span class="number">085</span>bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
<span class="keyword">Date</span>:   Sat Mar <span class="number">15</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">33</span> <span class="number">2008</span> -<span class="number">0700</span>

    removed unnecessary test code

<span class="keyword">commit</span> a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
<span class="keyword">Date</span>:   Sat Mar <span class="number">15</span> <span class="number">10</span>:<span class="number">31</span>:<span class="number">28</span> <span class="number">2008</span> -<span class="number">0700</span>

    <span class="keyword">first</span> <span class="keyword">commit</span></span>
</code></pre><p>默认不用任何参数的话，<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。看到了吗，每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明。</p>
<p><code>git log</code> 有许多选项可以帮助你搜寻感兴趣的提交，接下来我们介绍些最常用的。</p>
<p>我们常用 <code>-p</code> 选项展开显示每次提交的内容差异，用 <code>-2</code> 则仅显示最近的两次更新：</p>
<pre><code>$ git log -p -2
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

diff --git a/Rakefile b/Rakefile
index a874b73..8f94139 100644
-<span class="ruby">-- a/<span class="constant">Rakefile</span>
</span>+++ b/Rakefile
@@ -5,5 +5,5 @@ require 'rake/gempackagetask'
 spec = Gem::Specification.new do |s|
     s.name      =   "simplegit"
-<span class="ruby">    s.version   =   <span class="string">"0.1.0"</span>
</span>+    s.version   =   "0.1.1"
     s.author    =   "Scott Chacon"
     s.email     =   "schacon@gee-mail.com

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary test code

diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index a0a60ae..47c6340 100644
-<span class="ruby">-- a/lib/simplegit.rb
</span>+++ b/lib/simplegit.rb
@@ -18,8 +18,3 @@ class SimpleGit
     end

 end
-<span class="ruby">
</span>-<span class="ruby"><span class="keyword">if</span> <span class="variable">$0</span> == __FILE_<span class="number">_</span>
</span>-<span class="ruby">  git = <span class="constant">SimpleGit</span>.new
</span>-<span class="ruby">  puts git.show
</span>-<span class="ruby"><span class="keyword">end</span>
</span>\ No newline at end of file
</code></pre><p>该选项除了显示基本信息之外，还在附带了每次 commit 的变化。当进行代码审查，或者快速浏览某个搭档提交的 commit 的变化的时候，这个参数就非常有用了。</p>
<p>某些时候，单词层面的对比，比行层面的对比，更加容易观察。Git 提供了 <code>--word-diff</code> 选项。我们可以将其添加到 <code>git log -p</code> 命令的后面，从而获取单词层面上的对比。在程序代码中进行单词层面的对比常常是没什么用的。不过当你需要在书籍、论文这种很大的文本文件上进行对比的时候，这个功能就显出用武之地了。下面是一个简单的例子：</p>
<pre><code>$ git <span class="built_in">log</span> -U1 <span class="comment">--word-diff</span>
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Mar <span class="number">17</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">11</span> <span class="number">2008</span> -<span class="number">0700</span>

    changed <span class="operator">the</span> <span class="built_in">version</span> <span class="built_in">number</span>

diff <span class="comment">--git a/Rakefile b/Rakefile</span>
index a874b73.<span class="number">.8</span>f94139 <span class="number">100644</span>
<span class="comment">--- a/Rakefile</span>
+++ b/Rakefile
@@ -<span class="number">7</span>,<span class="number">3</span> +<span class="number">7</span>,<span class="number">3</span> @@ spec = Gem::Specification.<span class="built_in">new</span> <span class="built_in">do</span> |s|
    s.name      =   <span class="string">"simplegit"</span>
    s.<span class="built_in">version</span>   =   [-<span class="string">"0.1.0"</span>-]{+<span class="string">"0.1.1"</span>+}
    s.author    =   <span class="string">"Scott Chacon"</span>
</code></pre><p>如你所见，这里并没有平常看到的添加行或者删除行的信息。这里的对比显示在行间。新增加的单词被 <code>{+ +}</code> 括起来，被删除的单词被 <code>[- -]</code> 括起来。在进行单词层面的对比的时候，你可能希望上下文（ context ）行数从默认的 3 行，减为 1 行，那么可以使用 <code>-U1</code> 选项。上面的例子中，我们就使用了这个选项。 </p>
<p>另外，<code>git log</code> 还提供了许多摘要选项可以用，比如 <code>--stat</code>，仅显示简要的增改行数统计：</p>
<pre><code>$ git log --stat
commit ca82a6dff817ec66f44342007202690a93763949
<span class="label">Author:</span> Scott Chacon &lt;schacon@gee-mail<span class="preprocessor">.com</span>&gt;
<span class="label">Date:</span>   Mon Mar <span class="number">17</span> <span class="number">21</span>:<span class="number">52</span>:<span class="number">11</span> <span class="number">2008</span> -<span class="number">0700</span>

    changed the version number

 Rakefile |    <span class="number">2</span> +-
 <span class="number">1</span> file changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)

commit <span class="number">085</span>bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
<span class="label">Author:</span> Scott Chacon &lt;schacon@gee-mail<span class="preprocessor">.com</span>&gt;
<span class="label">Date:</span>   Sat Mar <span class="number">15</span> <span class="number">16</span>:<span class="number">40</span>:<span class="number">33</span> <span class="number">2008</span> -<span class="number">0700</span>

    removed unnecessary test code

 lib/simplegit<span class="preprocessor">.rb</span> |    <span class="number">5</span> -----
 <span class="number">1</span> file changed, <span class="number">5</span> deletions(-)

commit a11bef06a3f659402fe7563abf99ad00de2209e6
<span class="label">Author:</span> Scott Chacon &lt;schacon@gee-mail<span class="preprocessor">.com</span>&gt;
<span class="label">Date:</span>   Sat Mar <span class="number">15</span> <span class="number">10</span>:<span class="number">31</span>:<span class="number">28</span> <span class="number">2008</span> -<span class="number">0700</span>

    first commit

 README           |    <span class="number">6</span> ++++++
 Rakefile         |   <span class="number">23</span> +++++++++++++++++++++++
 lib/simplegit<span class="preprocessor">.rb</span> |   <span class="number">25</span> +++++++++++++++++++++++++
 <span class="number">3</span> files changed, <span class="number">54</span> insertions(+)
</code></pre><p>每个提交都列出了修改过的文件，以及其中添加和移除的行数，并在最后列出所有增减行数小计。<br>还有个常用的 <code>--pretty</code> 选项，可以指定使用完全不同于默认格式的方式展示提交历史。比如用 <code>oneline</code> 将每个提交放在一行显示，这在提交数很大时非常有用。另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 可以用，展示的信息或多或少有些不同，请自己动手实践一下看看效果如何。</p>
<pre><code>$ git <span class="built_in">log</span> <span class="comment">--pretty=oneline</span>
ca82a6dff817ec66f44342007202690a93763949 changed <span class="operator">the</span> <span class="built_in">version</span> <span class="built_in">number</span>
<span class="number">085</span>bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test code
a11bef06a3f659402fe7563abf99ad00de2209e6 <span class="keyword">first</span> commit
</code></pre><p>但最有意思的是 <code>format</code>，可以定制要显示的记录格式，这样的输出便于后期编程提取分析，像这样：</p>
<pre><code>$ git <span class="keyword">log</span> --pretty=<span class="keyword">format</span>:<span class="string">"<span class="variable">%h</span> - <span class="variable">%an</span>, <span class="variable">%ar</span> : <span class="variable">%s</span>"</span>
ca82a6d - Scott Chacon, <span class="number">11</span> months ago : changed the version number
085bb3b - Scott Chacon, <span class="number">11</span> months ago : removed unnecessary test code
a11bef<span class="number">0</span> - Scott Chacon, <span class="number">11</span> months ago : first commit
</code></pre><p>表 2-1 列出了常用的格式占位符写法及其代表的意义。</p>
<!-- Attention to translators: this is a table declaration.
The lines must be formatted as follows
<TAB><First column text><TAB><Second column text>
-->

<pre><code>选项     说明
<span class="tag">%<span class="title">H</span></span>    提交对象（commit）的完整哈希字串
<span class="tag">%<span class="title">h</span></span>    提交对象的简短哈希字串
<span class="tag">%<span class="title">T</span></span>    树对象（tree）的完整哈希字串
<span class="tag">%<span class="title">t</span></span>    树对象的简短哈希字串
<span class="tag">%<span class="title">P</span></span>    父对象（parent）的完整哈希字串
<span class="tag">%<span class="title">p</span></span>    父对象的简短哈希字串
<span class="tag">%<span class="title">an</span></span>    作者（author）的名字
<span class="tag">%<span class="title">ae</span></span>    作者的电子邮件地址
<span class="tag">%<span class="title">ad</span></span>    作者修订日期（可以用 -date= 选项定制格式）
<span class="tag">%<span class="title">ar</span></span>    作者修订日期，按多久以前的方式显示
<span class="tag">%<span class="title">cn</span></span>    提交者(committer)的名字
<span class="tag">%<span class="title">ce</span></span>    提交者的电子邮件地址
<span class="tag">%<span class="title">cd</span></span>    提交日期
<span class="tag">%<span class="title">cr</span></span>    提交日期，按多久以前的方式显示
<span class="tag">%<span class="title">s</span></span>    提交说明
</code></pre><p>你一定奇怪<em>作者（author）</em>和<em>提交者（committer）</em>之间究竟有何差别，其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。我们会在第五章再详细介绍两者之间的细微差别。</p>
<p>用 oneline 或 format 时结合 <code>--graph</code> 选项，可以看到开头多出一些 ASCII 字符串表示的简单图形，形象地展示了每个提交所在的分支及其分化衍合情况。在我们之前提到的 Grit 项目仓库中可以看到：</p>
<pre><code>$ git <span class="built_in">log</span> <span class="comment">--pretty=format:"%h %s" --graph</span>
* <span class="number">2</span>d3acf9 ignore errors <span class="built_in">from</span> SIGCHLD <span class="command"><span class="keyword">on</span> <span class="title">trap</span></span>
*  <span class="number">5e3</span>ee11 Merge branch <span class="string">'master'</span> <span class="operator">of</span> git://github.com/dustin/grit
|\
| * <span class="number">420</span>eac9 Added <span class="operator">a</span> method <span class="keyword">for</span> getting <span class="operator">the</span> current branch.
* | <span class="number">30e367</span>c timeout code <span class="operator">and</span> tests
* | <span class="number">5</span>a09431 <span class="built_in">add</span> timeout protection <span class="built_in">to</span> grit
* | e1193f8 support <span class="keyword">for</span> heads <span class="operator">with</span> slashes <span class="operator">in</span> them
|/
* d6016bc <span class="built_in">require</span> <span class="built_in">time</span> <span class="keyword">for</span> xmlschema
*  <span class="number">11</span>d191e Merge branch <span class="string">'defunkt'</span> <span class="keyword">into</span> <span class="built_in">local</span>
</code></pre><p>以上只是简单介绍了一些 <code>git log</code> 命令支持的选项。表 2-2 还列出了一些其他常用的选项及其释义。</p>
<!-- Attention to translators: this is a table declaration.
The lines must be formatted as follows
<TAB><First column text><TAB><Second column text>
-->

<pre><code>选项    说明
-<span class="ruby">p    按补丁格式显示每个更新之间的差异。
</span>-<span class="ruby">-word-diff    按 word diff 格式显示差异。
</span>-<span class="ruby">-stat    显示每次更新的文件修改统计信息。
</span>-<span class="ruby">-shortstat    只显示 --stat 中最后的行数修改添加移除统计。
</span>-<span class="ruby">-name-only    仅在提交信息后显示已修改的文件清单。
</span>-<span class="ruby">-name-status    显示新增、修改、删除的文件清单。
</span>-<span class="ruby">-abbrev-commit    仅显示 <span class="constant">SHA</span>-<span class="number">1</span> 的前几个字符，而非所有的 <span class="number">40</span> 个字符。
</span>-<span class="ruby">-relative-date    使用较短的相对时间显示（比如，“<span class="number">2</span> weeks ago”）。
</span>-<span class="ruby">-graph    显示 <span class="constant">ASCII</span> 图形表示的分支合并历史。
</span>-<span class="ruby">-pretty    使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。
</span>-<span class="ruby">-oneline    `--pretty=oneline --abbrev-commit` 的简化用法。</span>
</code></pre><h3 id="限制输出长度">限制输出长度</h3>
<p>除了定制输出格式的选项之外，<code>git log</code> 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。之前我们已经看到过 <code>-2</code> 了，它只显示最近的两条提交，实际上，这是 <code>-&lt;n&gt;</code> 选项的写法，其中的 <code>n</code> 可以是任何自然数，表示仅显示最近的若干条提交。不过实践中我们是不太用这个选项的，Git 在输出所有提交时会自动调用分页程序（less），要看更早的更新只需翻到下页即可。</p>
<p>另外还有按照时间作限制的选项，比如 <code>--since</code> 和 <code>--until</code>。下面的命令列出所有最近两周内的提交：</p>
<pre><code>$ git <span class="built_in">log</span> <span class="comment">--since=2.weeks</span>
</code></pre><p>你可以给出各种时间格式，比如说具体的某一天（“2008-01-15”），或者是多久以前（“2 years 1 day 3 minutes ago”）。</p>
<p>还可以给出若干搜索条件，列出符合的提交。用 <code>--author</code> 选项显示指定作者的提交，用 <code>--grep</code> 选项搜索提交说明中的关键字。（请注意，如果要得到同时满足这两个选项搜索条件的提交，就必须用 <code>--all-match</code> 选项。否则，满足任意一个条件的提交都会被匹配出来）</p>
<p>另一个真正实用的<code>git log</code>选项是路径(path)，如果只关心某些文件或者目录的历史提交，可以在 <code>git log</code> 选项的最后指定它们的路径。因为是放在最后位置上的选项，所以用两个短划线（<code>--</code>）隔开之前的选项和后面限定的路径名。</p>
<p>表 2-3 还列出了其他常用的类似选项。</p>
<!-- Attention to translators: this is a table declaration.
The lines must be formatted as follows
<TAB><First column text><TAB><Second column text>
-->

<pre><code>选项    说明
-<span class="ruby">(n)    仅显示最近的 n 条提交
</span>-<span class="ruby">-since, --after    仅显示指定时间之后的提交。
</span>-<span class="ruby">-<span class="keyword">until</span>, --before    仅显示指定时间之前的提交。
</span>-<span class="ruby">-author    仅显示指定作者相关的提交。
</span>-<span class="ruby">-committer    仅显示指定提交者相关的提交。</span>
</code></pre><p>来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试脚本（位于项目的 t/ 目录下的文件），可以用下面的查询命令：</p>
<pre><code>$ git <span class="keyword">log</span> --pretty=<span class="string">"<span class="variable">%h</span> - <span class="variable">%s</span>"</span> --author=gitster --since=<span class="string">"2008-10-01"</span> \
   --before=<span class="string">"2008-11-01"</span> --<span class="keyword">no</span>-merges -- t/
<span class="number">5610</span>e3b - Fix testcase failure <span class="keyword">when</span> extended attribute
acd3b9e - Enhance hold_lock_file_for<span class="number">_</span>{update,append}()
f563754 - demonstrate breakage of detached checkout wi
d1a43f2 - <span class="keyword">reset</span> --hard/<span class="keyword">read</span>-tree --<span class="keyword">reset</span> -u: remove un
<span class="number">51</span>a94af - Fix <span class="string">"checkout --track -b newbranch"</span> on detac
b0ad11e - pull: allow <span class="string">"git pull origin <span class="variable">$something</span>:<span class="variable">$cur</span></span>
</code></pre><p>Git 项目有 20,000 多条提交，但我们给出搜索选项后，仅列出了其中满足条件的 6 条。</p>
<h3 id="使用图形化工具查阅提交历史">使用图形化工具查阅提交历史</h3>
<p>有时候图形化工具更容易展示历史提交的变化，随 Git 一同发布的 gitk 就是这样一种工具。它是用 Tcl/Tk 写成的，基本上相当于 <code>git log</code> 命令的可视化版本，凡是 <code>git log</code> 可以用的选项也都能用在 gitk 上。在项目工作目录中输入 gitk 命令后，就会启动图 2-2 所示的界面。</p>
<p><img src="http://git-scm.com/figures/18333fig0202-tn.png" alt="图 2-2. gitk 的图形界面"></p>
<p>上半个窗口显示的是历次提交的分支祖先图谱，下半个窗口显示当前点选的提交对应的具体差异。</p>
<hr>
<h2 id="撤消操作">撤消操作</h2>
<p>任何时候，你都有可能需要撤消刚才所做的某些操作。接下来，我们会介绍一些基本的撤消操作相关的命令。请注意，有些撤销操作是不可逆的，所以请务必谨慎小心，一旦失误，就有可能丢失部分工作成果。</p>
<h3 id="修改最后一次提交">修改最后一次提交</h3>
<p>有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 <code>--amend</code> 选项重新提交：</p>
<pre><code><span class="comment">$</span> <span class="comment">git</span> <span class="comment">commit</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">amend</span>
</code></pre><p>此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。</p>
<p>启动文本编辑器后，会看到上次提交时的说明，编辑它确认没问题后保存退出，就会使用新的提交说明覆盖刚才失误的提交。</p>
<p>如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 <code>--amend</code> 提交：</p>
<pre><code><span class="variable">$ </span>git commit -m <span class="string">'initial commit'</span>
<span class="variable">$ </span>git add forgotten_file
<span class="variable">$ </span>git commit --amend
</code></pre><p>上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。</p>
<h3 id="取消已经暂存的文件">取消已经暂存的文件</h3>
<p>接下来的两个小节将演示如何取消暂存区域中的文件，以及如何取消工作目录中已修改的文件。不用担心，查看文件状态的时候就提示了该如何撤消，所以不需要死记硬背。来看下面的例子，有两个修改过的文件，我们想要分开提交，但不小心用 <code>git add .</code> 全加到了暂存区域。该如何撤消暂存其中的一个文件呢？其实，<code>git status</code> 的命令输出已经告诉了我们该怎么做：</p>
<pre><code>$ git add .
$ git status
<span class="keyword">On</span> branch master
Changes <span class="keyword">to</span> be committed:
  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)

        modified:   README.txt
        modified:   benchmarks.rb
</code></pre><p>就在 “Changes to be committed” 下面，括号中有提示，可以使用 <code>git reset HEAD &lt;file&gt;...</code> 的方式取消暂存。好吧，我们来试试取消暂存 benchmarks.rb 文件：</p>
<pre><code>$ git reset HEAD benchmarks.rb
Unstaged changes <span class="keyword">after</span> reset:
M       benchmarks.rb
$ git status
<span class="keyword">On</span> branch master
Changes <span class="keyword">to</span> be committed:
  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)

        modified:   README.txt

Changes <span class="keyword">not</span> staged <span class="keyword">for</span> commit:
  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> update what will be committed)
  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working directory)

        modified:   benchmarks.rb
</code></pre><p>这条命令看起来有些古怪，先别管，能用就行。现在 benchmarks.rb 文件又回到了之前已修改未暂存的状态。</p>
<h3 id="取消对文件的修改">取消对文件的修改</h3>
<p>如果觉得刚才对 benchmarks.rb 的修改完全没有必要，该如何取消修改，回到之前的状态（也就是修改之前的版本）呢？<code>git status</code> 同样提示了具体的撤消方法，接着上面的例子，现在未暂存区域看起来像这样：</p>
<pre><code>Changes <span class="keyword">not</span> staged <span class="keyword">for</span> commit:
  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> update what will be committed)
  (<span class="keyword">use</span> <span class="string">"git checkout -- &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working directory)

        modified:   benchmarks.rb
</code></pre><p>在第二个括号中，我们看到了抛弃文件修改的命令（至少在 Git 1.6.1 以及更高版本中会这样提示，如果你还在用老版本，我们强烈建议你升级，以获取最佳的用户体验），让我们试试看：</p>
<pre><code>$ git checkout <span class="comment">-- benchmarks.rb</span>
$ git status
<span class="keyword">On</span> branch master
Changes <span class="keyword">to</span> be committed:
  (<span class="keyword">use</span> <span class="string">"git reset HEAD &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)

        modified:   README.txt
</code></pre><p>可以看到，该文件已经恢复到修改前的版本。你可能已经意识到了，这条命令有些危险，所有对文件的修改都没有了，因为我们刚刚把之前版本的文件复制过来重写了此文件。所以在用这条命令前，请务必确定真的不再需要保留刚才的修改。如果只是想回退版本，同时保留刚才的修改以便将来继续工作，可以用下章介绍的 stashing 和分支来处理，应该会更好些。</p>
<p>记住，任何已经提交到 Git 的都可以被恢复。即便在已经删除的分支中的提交，或者用 <code>--amend</code> 重新改写的提交，都可以被恢复（关于数据恢复的内容见第九章）。所以，你可能失去的数据，仅限于没有提交过的，对 Git 来说它们就像从未存在过一样。</p>
<hr>
<h2 id="远程仓库的使用">远程仓库的使用</h2>
<p>要参与任何一个 Git 项目的协作，必须要了解该如何管理远程仓库。远程仓库是指托管在网络上的项目仓库，可能会有好多个，其中有些你只能读，另外有些可以写。同他人协作开发某个项目时，需要管理这些远程仓库，以便推送或拉取数据，分享各自的工作进展。<br>管理远程仓库的工作，包括添加远程库，移除废弃的远程库，管理各式远程库分支，定义是否跟踪这些分支，等等。本节我们将详细讨论远程库的管理和使用。</p>
<h3 id="查看当前的远程库">查看当前的远程库</h3>
<p>要查看当前配置有哪些远程仓库，可以用 <code>git remote</code> 命令，它会列出每个远程库的简短名字。在克隆完某个项目后，至少可以看到一个名为 origin 的远程库，Git 默认使用这个名字来标识你所克隆的原始仓库：</p>
<pre><code>$ git clone git://github.com/schacon/ticgit.git
Cloning into <span class="string">'ticgit'</span><span class="keyword">...</span>
remote: Reusing existing pack: <span class="number">1857</span>, done.
remote: Total <span class="number">1857</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)
Receiving objects: <span class="number">100</span>% (<span class="number">1857</span>/<span class="number">1857</span>), <span class="number">374.35</span> KiB | <span class="number">193.00</span> KiB/s, done.
Resolving deltas: <span class="number">100</span>% (<span class="number">772</span>/<span class="number">772</span>), done.
Checking connectivity... done.
$ cd ticgit
$ git remote
origin
</code></pre><p>也可以加上 <code>-v</code> 选项（译注：此为 <code>--verbose</code> 的简写，取首字母），显示对应的克隆地址：</p>
<pre><code>$ git remote -v
origin  git://github<span class="preprocessor">.com</span>/schacon/ticgit<span class="preprocessor">.git</span> (fetch)
origin  git://github<span class="preprocessor">.com</span>/schacon/ticgit<span class="preprocessor">.git</span> (<span class="keyword">push</span>)
</code></pre><p>如果有多个远程仓库，此命令将全部列出。比如在我的 Grit 项目中，可以看到：</p>
<pre><code>$ cd grit
$ git remote -v
bakkdoor  git://github<span class="preprocessor">.com</span>/bakkdoor/grit<span class="preprocessor">.git</span>
cho45     git://github<span class="preprocessor">.com</span>/cho45/grit<span class="preprocessor">.git</span>
defunkt   git://github<span class="preprocessor">.com</span>/defunkt/grit<span class="preprocessor">.git</span>
koke      git://github<span class="preprocessor">.com</span>/koke/grit<span class="preprocessor">.git</span>
origin    git@github<span class="preprocessor">.com</span>:mojombo/grit<span class="preprocessor">.git</span>
</code></pre><p>这样一来，我就可以非常轻松地从这些用户的仓库中，拉取他们的提交到本地。请注意，上面列出的地址只有 origin 用的是 SSH URL 链接，所以也只有这个仓库我能推送数据上去（我们会在第四章解释原因）。</p>
<h3 id="添加远程仓库">添加远程仓库</h3>
<p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用，运行 <code>git remote add [shortname] [url]</code>：</p>
<pre><code>$ git remote
origin
$ git remote <span class="keyword">add</span> pb git://github<span class="preprocessor">.com</span>/paulboone/ticgit<span class="preprocessor">.git</span>
$ git remote -v
origin    git://github<span class="preprocessor">.com</span>/schacon/ticgit<span class="preprocessor">.git</span>
pb    git://github<span class="preprocessor">.com</span>/paulboone/ticgit<span class="preprocessor">.git</span>
</code></pre><p>现在可以用字符串 <code>pb</code> 指代对应的仓库地址了。比如说，要抓取所有 Paul 有的，但本地仓库没有的信息，可以运行 <code>git fetch pb</code>：</p>
<pre><code>$ git fetch pb
remote: Counting objects: <span class="number">58</span>, <span class="keyword">done</span>.
remote: Compressing objects: <span class="number">100</span>% (<span class="number">41</span>/<span class="number">41</span>), <span class="keyword">done</span>.
remote: Total <span class="number">44</span> (delta <span class="number">24</span>), reused <span class="number">1</span> (delta <span class="number">0</span>)
Unpacking objects: <span class="number">100</span>% (<span class="number">44</span>/<span class="number">44</span>), <span class="keyword">done</span>.
From git:<span class="comment">//github.com/paulboone/ticgit</span>
 * [<span class="keyword">new</span> branch]      master     -&gt; pb/master
 * [<span class="keyword">new</span> branch]      ticgit     -&gt; pb/ticgit
</code></pre><p>现在，Paul 的主干分支（master）已经完全可以在本地访问了，对应的名字是 <code>pb/master</code>，你可以将它合并到自己的某个分支，或者切换到这个分支，看看有些什么有趣的更新。</p>
<h3 id="从远程仓库抓取数据">从远程仓库抓取数据</h3>
<p>正如之前所看到的，可以用下面的命令从远程仓库抓取数据到本地：</p>
<pre><code><span class="variable">$ </span>git fetch [remote-name]
</code></pre><p>此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后，你就可以在本地访问该远程仓库中的所有分支，将其中某个分支合并到本地，或者只是取出某个分支，一探究竟。（我们会在第三章详细讨论关于分支的概念和操作。）</p>
<p>如果是克隆了一个仓库，此命令会自动将远程仓库归于 origin 名下。所以，<code>git fetch origin</code> 会抓取从你上次克隆以来别人上传到此远程仓库中的所有更新（或是上次 fetch 以来别人提交的更新）。有一点很重要，需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。</p>
<p>如果设置了某个分支用于跟踪某个远端仓库的分支（参见下节及第三章的内容），可以使用 <code>git pull</code> 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用，既快且好。实际上，默认情况下 <code>git clone</code> 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支（假设远程仓库确实有 master 分支）。所以一般我们运行 <code>git pull</code>，目的都是要从原始克隆的远端仓库中抓取数据后，合并到工作目录中的当前分支。</p>
<h3 id="推送数据到远程仓库">推送数据到远程仓库</h3>
<p>项目进行到一个阶段，要同别人分享目前的成果，可以将本地仓库中的数据推送到远程仓库。实现这个任务的命令很简单： <code>git push [remote-name] [branch-name]</code>。如果要把本地的 master 分支推送到 <code>origin</code> 服务器上（再次说明下，克隆操作会自动使用默认的 master 和 origin 名字），可以运行下面的命令：</p>
<pre><code><span class="variable">$ </span>git push origin master
</code></pre><p>只有在所克隆的服务器上有写权限，或者同一时刻没有其他人在推数据，这条命令才会如期完成任务。如果在你推数据前，已经有其他人推送了若干更新，那你的推送操作就会被驳回。你必须先把他们的更新抓取到本地，合并到自己的项目中，然后才可以再次推送。有关推送数据到远程仓库的详细内容见第三章。</p>
<h3 id="查看远程仓库信息">查看远程仓库信息</h3>
<p>我们可以通过命令 <code>git remote show [remote-name]</code> 查看某个远程仓库的详细信息，比如要看所克隆的 <code>origin</code> 仓库，可以运行：</p>
<pre><code>$ git remote show origin
* remote origin
  <span class="built_in">URL</span>: git://github.com/schacon/ticgit.git
  Remote branch merged <span class="operator">with</span> <span class="string">'git pull'</span> <span class="keyword">while</span> <span class="command"><span class="keyword">on</span> <span class="title">branch</span> <span class="title">master</span></span>
    master
  Tracked remote branches
    master
    ticgit
</code></pre><p>除了对应的克隆地址外，它还给出了许多额外的信息。它友善地告诉你如果是在 master 分支，就可以用 <code>git pull</code> 命令抓取数据合并到本地。另外还列出了所有处于跟踪状态中的远端分支。</p>
<p>上面的例子非常简单，而随着使用 Git 的深入，<code>git remote show</code> 给出的信息可能会像这样：</p>
<pre><code>$ git remote show origin
* remote origin
  <span class="built_in">URL</span>: git@github.com:defunkt/github.git
  Remote branch merged <span class="operator">with</span> <span class="string">'git pull'</span> <span class="keyword">while</span> <span class="command"><span class="keyword">on</span> <span class="title">branch</span> <span class="title">issues</span></span>
    issues
  Remote branch merged <span class="operator">with</span> <span class="string">'git pull'</span> <span class="keyword">while</span> <span class="command"><span class="keyword">on</span> <span class="title">branch</span> <span class="title">master</span></span>
    master
  New remote branches (next fetch will store <span class="operator">in</span> remotes/origin)
    caching
  Stale tracking branches (use <span class="string">'git remote prune'</span>)
    libwalker
    walker2
  Tracked remote branches
    acl
    apiv2
    dashboard2
    issues
    master
    postgres
  Local branch pushed <span class="operator">with</span> <span class="string">'git push'</span>
    master:master
</code></pre><p>它告诉我们，运行 <code>git push</code> 时缺省推送的分支是什么（译注：最后两行）。它还显示了有哪些远端分支还没有同步到本地（译注：第六行的 <code>caching</code> 分支），哪些已同步到本地的远端分支在远端服务器上已被删除（译注：<code>Stale tracking branches</code> 下面的两个分支），以及运行 <code>git pull</code> 时将自动合并哪些分支（译注：前四行中列出的 <code>issues</code> 和 <code>master</code> 分支）。</p>
<h3 id="远程仓库的删除和重命名">远程仓库的删除和重命名</h3>
<p>在新版 Git 中可以用 <code>git remote rename</code> 命令修改某个远程仓库在本地的简称，比如想把 <code>pb</code> 改成 <code>paul</code>，可以这么运行：</p>
<pre><code><span class="variable">$ </span>git remote rename pb paul
<span class="variable">$ </span>git remote
origin
paul
</code></pre><p>注意，对远程仓库的重命名，也会使对应的分支名称发生变化，原来的 <code>pb/master</code> 分支现在成了 <code>paul/master</code>。</p>
<p>碰到远端仓库服务器迁移，或者原来的克隆镜像不再使用，又或者某个参与者不再贡献代码，那么需要移除对应的远端仓库，可以运行 <code>git remote rm</code> 命令：</p>
<pre><code><span class="variable">$ </span>git remote rm paul
<span class="variable">$ </span>git remote
origin
</code></pre><hr>
<h2 id="打标签">打标签</h2>
<p>同大多数 VCS 一样，Git 也可以对某一时间点上的版本打上标签。人们在发布某个软件版本（比如 v1.0 等等）的时候，经常这么做。本节我们一起来学习如何列出所有可用的标签，如何新建标签，以及各种不同类型标签之间的差别。</p>
<h3 id="列显已有的标签">列显已有的标签</h3>
<p>列出现有标签的命令非常简单，直接运行 <code>git tag</code> 即可：</p>
<pre><code><span class="variable">$ </span>git tag
v<span class="number">0</span>.<span class="number">1</span>
v1.<span class="number">3</span>
</code></pre><p>显示的标签按字母顺序排列，所以标签的先后并不表示重要程度的轻重。</p>
<p>我们可以用特定的搜索模式列出符合条件的标签。在 Git 自身项目仓库中，有着超过 240 个标签，如果你只对 1.4.2 系列的版本感兴趣，可以运行下面的命令：</p>
<pre><code>$ git <span class="built_in">tag</span> <span class="attribute">-l</span> <span class="string">'v1.4.2.*'</span>
v1<span class="number">.4</span><span class="number">.2</span><span class="number">.1</span>
v1<span class="number">.4</span><span class="number">.2</span><span class="number">.2</span>
v1<span class="number">.4</span><span class="number">.2</span><span class="number">.3</span>
v1<span class="number">.4</span><span class="number">.2</span><span class="number">.4</span>
</code></pre><h3 id="新建标签">新建标签</h3>
<p>Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。</p>
<h3 id="含附注的标签">含附注的标签</h3>
<p>创建一个含附注类型的标签非常简单，用 <code>-a</code> （译注：取 <code>annotated</code> 的首字母）指定标签名字即可：</p>
<pre><code>$ git <span class="built_in">tag</span> <span class="attribute">-a</span> v1<span class="number">.4</span> <span class="attribute">-m</span> <span class="string">'my version 1.4'</span>
$ git <span class="built_in">tag</span>
v0<span class="number">.1</span>
v1<span class="number">.3</span>
v1<span class="number">.4</span>
</code></pre><p>而 <code>-m</code> 选项则指定了对应的标签说明，Git 会将此说明一同保存在标签对象中。如果没有给出该选项，Git 会启动文本编辑软件供你输入标签说明。</p>
<p>可以使用 <code>git show</code> 命令查看相应标签的版本信息，并连同显示打标签时的提交对象。</p>
<pre><code>$ git show v1<span class="number">.4</span>
<span class="built_in">tag</span> v1<span class="number">.4</span>
Tagger: Scott Chacon <span class="subst">&lt;</span>schacon@gee<span class="attribute">-mail</span><span class="built_in">.</span>com<span class="subst">&gt;</span>
<span class="built_in">Date</span>:   Mon Feb <span class="number">9</span> <span class="number">14</span>:<span class="number">45</span>:<span class="number">11</span> <span class="number">2009</span> <span class="subst">-</span><span class="number">0800</span>

my version <span class="number">1.4</span>

commit <span class="number">15027957951</span>b64cf874c3557a0f3547bd83b3ff6
Merge: <span class="number">4</span>a447f7<span class="attribute">...</span> a6b4c97<span class="attribute">...</span>
Author: Scott Chacon <span class="subst">&lt;</span>schacon@gee<span class="attribute">-mail</span><span class="built_in">.</span>com<span class="subst">&gt;</span>
<span class="built_in">Date</span>:   Sun Feb <span class="number">8</span> <span class="number">19</span>:<span class="number">02</span>:<span class="number">46</span> <span class="number">2009</span> <span class="subst">-</span><span class="number">0800</span>

    Merge branch <span class="string">'experiment'</span>
</code></pre><p>我们可以看到在提交对象信息上面，列出了此标签的提交者和提交时间，以及相应的标签说明。</p>
<h3 id="签署标签">签署标签</h3>
<p>如果你有自己的私钥，还可以用 GPG 来签署标签，只需要把之前的 <code>-a</code> 改为 <code>-s</code> （译注： 取 <code>signed</code> 的首字母）即可：</p>
<pre><code>$ git <span class="built_in">tag</span> <span class="attribute">-s</span> v1<span class="number">.5</span> <span class="attribute">-m</span> <span class="string">'my signed 1.5 tag'</span>
You need a passphrase <span class="keyword">to</span> unlock the secret key for
user: <span class="string">"Scott Chacon &lt;schacon@gee-mail.com&gt;"</span>
<span class="number">1024</span><span class="attribute">-bit</span> DSA key, ID F721C45A, created <span class="number">2009</span><span class="subst">-</span><span class="number">02</span><span class="subst">-</span><span class="number">09</span>
</code></pre><p>现在再运行 <code>git show</code> 会看到对应的 GPG 签名也附在其内：</p>
<pre><code>$ git <span class="operator"><span class="keyword">show</span> v1<span class="number">.5</span>
tag v1<span class="number">.5</span>
Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;
<span class="keyword">Date</span>:   Mon Feb <span class="number">9</span> <span class="number">15</span>:<span class="number">22</span>:<span class="number">20</span> <span class="number">2009</span> -<span class="number">0800</span>

my signed <span class="number">1.5</span> tag
-----<span class="keyword">BEGIN</span> PGP SIGNATURE-----
Version: GnuPG v1<span class="number">.4</span><span class="number">.8</span> (Darwin)

iEYEABECAAYFAkmQurIACgkQON3DxfchxFr5cACeIMN+ZxLKggJQf0QYiQBwgySN
Ki0An2JeAVUCAiJ7Ox6ZEtK+NvZAj82/
=WryJ
-----<span class="keyword">END</span> PGP SIGNATURE-----
<span class="keyword">commit</span> <span class="number">15027957951</span>b64cf874c3557a0f3547bd83b3ff6
<span class="keyword">Merge</span>: <span class="number">4</span>a447f7... a6b4c97...
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
<span class="keyword">Date</span>:   Sun Feb <span class="number">8</span> <span class="number">19</span>:<span class="number">02</span>:<span class="number">46</span> <span class="number">2009</span> -<span class="number">0800</span>

    <span class="keyword">Merge</span> branch <span class="string">'experiment'</span></span>
</code></pre><p>稍后我们再学习如何验证已经签署的标签。</p>
<h3 id="轻量级标签">轻量级标签</h3>
<p>轻量级标签实际上就是一个保存着对应提交对象的校验和信息的文件。要创建这样的标签，一个 <code>-a</code>，<code>-s</code> 或 <code>-m</code> 选项都不用，直接给出标签名字即可：</p>
<pre><code>$ git <span class="built_in">tag</span> v1<span class="number">.4</span><span class="attribute">-lw</span>
$ git <span class="built_in">tag</span>
v0<span class="number">.1</span>
v1<span class="number">.3</span>
v1<span class="number">.4</span>
v1<span class="number">.4</span><span class="attribute">-lw</span>
v1<span class="number">.5</span>
</code></pre><p>现在运行 <code>git show</code> 查看此标签信息，就只有相应的提交对象摘要：</p>
<pre><code>$ git <span class="operator"><span class="keyword">show</span> v1<span class="number">.4</span>-lw
<span class="keyword">commit</span> <span class="number">15027957951</span>b64cf874c3557a0f3547bd83b3ff6
<span class="keyword">Merge</span>: <span class="number">4</span>a447f7... a6b4c97...
Author: Scott Chacon &lt;schacon@gee-mail.com&gt;
<span class="keyword">Date</span>:   Sun Feb <span class="number">8</span> <span class="number">19</span>:<span class="number">02</span>:<span class="number">46</span> <span class="number">2009</span> -<span class="number">0800</span>

    <span class="keyword">Merge</span> branch <span class="string">'experiment'</span></span>
</code></pre><h3 id="验证标签">验证标签</h3>
<p>可以使用 <code>git tag -v [tag-name]</code> （译注：取 <code>verify</code> 的首字母）的方式验证已经签署的标签。此命令会调用 GPG 来验证签名，所以你需要有签署者的公钥，存放在 keyring 中，才能验证：</p>
<pre><code>$ git tag -v v1.4.2.1
object 883653babd8ee7ea23e6a5c392bb739348b1eb61
type <span class="operator"><span class="keyword">commit</span>
tag v1<span class="number">.4</span><span class="number">.2</span><span class="number">.1</span>
tagger Junio C Hamano &lt;junkio@cox.net&gt; <span class="number">1158138501</span> -<span class="number">0700</span>

GIT <span class="number">1.4</span><span class="number">.2</span><span class="number">.1</span>

Minor fixes since <span class="number">1.4</span><span class="number">.2</span>, including git-mv <span class="keyword">and</span> git-http <span class="keyword">with</span> alternates.
gpg: Signature made Wed Sep <span class="number">13</span> <span class="number">02</span>:<span class="number">08</span>:<span class="number">25</span> <span class="number">2006</span> PDT <span class="keyword">using</span> DSA <span class="keyword">key</span> ID F3119B9A
gpg: Good signature <span class="keyword">from</span> <span class="string">"Junio C Hamano &lt;junkio@cox.net&gt;"</span>
gpg:                 aka <span class="string">"[jpeg image of size 1513]"</span>
<span class="keyword">Primary</span> <span class="keyword">key</span> fingerprint: <span class="number">3565</span> <span class="number">2</span>A26 <span class="number">2040</span> E066 C9A7  <span class="number">4</span>A7D C0C6 D9A4 F311 <span class="number">9</span>B9A</span>
</code></pre><p>若是没有签署者的公钥，会报告类似下面这样的错误：</p>
<pre><code><span class="attribute">gpg</span>: <span class="string">Signature made Wed Sep 13 02:08:25 2006 PDT using DSA key ID F3119B9A</span>
<span class="attribute">gpg</span>: <span class="string">Can't check signature: public key not found</span>
<span class="attribute">error</span>: <span class="string">could not verify the tag 'v1.4.2.1'</span>
</code></pre><h3 id="后期加注标签">后期加注标签</h3>
<p>你甚至可以在后期对早先的某次提交加注标签。比如在下面展示的提交历史中：</p>
<pre><code>$ git <span class="built_in">log</span> <span class="comment">--pretty=oneline</span>
<span class="number">15027957951</span>b64cf874c3557a0f3547bd83b3ff6 Merge branch <span class="string">'experiment'</span>
a6b4c97498bd301d84096da251c98a07c7723e65 beginning <span class="built_in">write</span> support
<span class="number">0</span>d52aaab4479697da7686c15f77a3d64d9165190 <span class="constant">one</span> more thing
<span class="number">6</span>d52a271eda8725415634dd79daabbc4d9b6008e Merge branch <span class="string">'experiment'</span>
<span class="number">0</span>b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added <span class="operator">a</span> commit <span class="function"><span class="keyword">function</span></span>
<span class="number">4682</span>c3261057305bdd616e23b64b0857d832627b added <span class="operator">a</span> todo <span class="built_in">file</span>
<span class="number">166</span>ae0c4d3f420721acbb115cc33848dfcc2121a started <span class="built_in">write</span> support
<span class="number">9</span>fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
<span class="number">964</span>f16d36dfccde844893cac5b347e7b3d44abbc commit <span class="operator">the</span> todo
<span class="number">8</span>a5cbc430f1a9c3d00faaeffd07798508422908a updated readme
</code></pre><p>我们忘了在提交 “updated rakefile” 后为此项目打上版本号 v1.2，没关系，现在也能做。只要在打标签的时候跟上对应提交对象的校验和（或前几位字符）即可：</p>
<pre><code>$ git <span class="built_in">tag</span> <span class="attribute">-a</span> v1<span class="number">.2</span> <span class="number">9</span>fceb02
</code></pre><p>可以看到我们已经补上了标签：</p>
<pre><code>$ git tag
v0.1
v1.2
v1.3
v1.4
v1.4-lw
v1.5

$ git show v1.2
tag v1.2
Tagger: Scott Chacon &lt;schacon@gee-mail.com&gt;
Date:   Mon Feb <span class="number">9</span> <span class="number">15</span>:<span class="number">32</span>:<span class="number">16</span> <span class="number">2009</span> -<span class="number">0800</span>

version <span class="number">1.2</span>
commit 9fceb02d0ae598e95dc970b74767f19372d61af8
Author: Magnus Chacon &lt;mchacon@gee-mail.com&gt;
Date:   Sun Apr <span class="number">27</span> <span class="number">20</span>:<span class="number">43</span>:<span class="number">35</span> <span class="number">2008</span> -<span class="number">0700</span>

    updated rakefile
<span class="keyword">...</span>
</code></pre><h3 id="分享标签">分享标签</h3>
<p>默认情况下，<code>git push</code> 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 <code>git push origin [tagname]</code> 即可： </p>
<pre><code>$ git push origin v1<span class="number">.5</span>
Counting objects: <span class="number">50</span>, <span class="keyword">done</span>.
Compressing objects: <span class="number">100</span>% (<span class="number">38</span>/<span class="number">38</span>), <span class="keyword">done</span>.
Writing objects: <span class="number">100</span>% (<span class="number">44</span>/<span class="number">44</span>), <span class="number">4.56</span> KiB, <span class="keyword">done</span>.
Total <span class="number">44</span> (delta <span class="number">18</span>), reused <span class="number">8</span> (delta <span class="number">1</span>)
To git@github.com:schacon/simplegit.git
* [<span class="keyword">new</span> tag]         v1<span class="number">.5</span> -&gt; v1<span class="number">.5</span>
</code></pre><p>如果要一次推送所有本地新增的标签上去，可以使用 <code>--tags</code> 选项：</p>
<pre><code>$ git push origin --tags
Counting <span class="attribute">objects</span>: <span class="number">50</span>, done.
Compressing <span class="attribute">objects</span>: <span class="number">100</span>% (<span class="number">38</span>/<span class="number">38</span>), done.
Writing <span class="attribute">objects</span>: <span class="number">100</span>% (<span class="number">44</span>/<span class="number">44</span>), <span class="number">4.56</span> KiB, done.
Total <span class="number">44</span> (delta <span class="number">18</span>), reused <span class="number">8</span> (delta <span class="number">1</span>)
To git<span class="property">@github</span>.<span class="attribute">com</span>:schacon/simplegit.git
 * [<span class="keyword">new</span> tag]         v0<span class="number">.1</span><span class="function"> -&gt;</span> v0<span class="number">.1</span>
 * [<span class="keyword">new</span> tag]         v1<span class="number">.2</span><span class="function"> -&gt;</span> v1<span class="number">.2</span>
 * [<span class="keyword">new</span> tag]         v1<span class="number">.4</span><span class="function"> -&gt;</span> v1<span class="number">.4</span>
 * [<span class="keyword">new</span> tag]         v1<span class="number">.4</span>-lw<span class="function"> -&gt;</span> v1<span class="number">.4</span>-lw
 * [<span class="keyword">new</span> tag]         v1<span class="number">.5</span><span class="function"> -&gt;</span> v1<span class="number">.5</span>
</code></pre><p>现在，其他人克隆共享仓库或拉取数据同步后，也会看到这些标签。</p>
<hr>
<h2 id="技巧和窍门">技巧和窍门</h2>
<p>在结束本章之前，我还想和大家分享一些 Git 使用的技巧和窍门。很多使用 Git 的开发者可能根本就没用过这些技巧，我们也不是说在读过本书后非得用这些技巧不可，但至少应该有所了解吧。说实话，有了这些小窍门，我们的工作可以变得更简单，更轻松，更高效。</p>
<h3 id="自动补全">自动补全</h3>
<p>如果你用的是 Bash shell，可以试试看 Git 提供的自动补全脚本。下载 Git 的源代码，进入  <code>contrib/completion</code> 目录，会看到一个 <code>git-completion.bash</code> 文件。将此文件复制到你自己的用户主目录中（译注：按照下面的示例，还应改名加上点：<code>cp git-completion.bash ~/.git-completion.bash</code>），并把下面一行内容添加到你的 <code>.bashrc</code> 文件中：</p>
<pre><code>source ~/<span class="preprocessor">.git</span>-completion<span class="preprocessor">.bash</span>
</code></pre><p>也可以为系统上所有用户都设置默认使用此脚本。Mac 上将此脚本复制到 <code>/opt/local/etc/bash_completion.d</code> 目录中，Linux 上则复制到 <code>/etc/bash_completion.d/</code> 目录中。这两处目录中的脚本，都会在 Bash 启动时自动加载。</p>
<p>如果在 Windows 上安装了 msysGit，默认使用的 Git Bash 就已经配好了这个自动补全脚本，可以直接使用。</p>
<p>在输入 Git 命令的时候可以敲两次跳格键（Tab），就会看到列出所有匹配的可用命令建议：</p>
<pre><code>$ git co<span class="tag">&lt;<span class="title">tab</span>&gt;</span><span class="tag">&lt;<span class="title">tab</span>&gt;</span>
commit config
</code></pre><p>此例中，键入 git co 然后连按两次 Tab 键，会看到两个相关的建议（命令） commit 和 config。继而输入 <code>m&lt;tab&gt;</code> 会自动完成 <code>git commit</code> 命令的输入。</p>
<p>命令的选项也可以用这种方式自动完成，其实这种情况更实用些。比如运行 <code>git log</code> 的时候忘了相关选项的名字，可以输入开头的几个字母，然后敲 Tab 键看看有哪些匹配的：</p>
<pre><code><span class="comment">$</span> <span class="comment">git</span> <span class="comment">log</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">s</span>&lt;<span class="comment">tab</span>&gt;
<span class="literal">-</span><span class="literal">-</span><span class="comment">shortstat</span>  <span class="literal">-</span><span class="literal">-</span><span class="comment">since=</span>  <span class="literal">-</span><span class="literal">-</span><span class="comment">src</span><span class="literal">-</span><span class="comment">prefix=</span>  <span class="literal">-</span><span class="literal">-</span><span class="comment">stat</span>   <span class="literal">-</span><span class="literal">-</span><span class="comment">summary</span>
</code></pre><p>这个技巧不错吧，可以节省很多输入和查阅文档的时间。</p>
<h3 id="Git_命令别名">Git 命令别名</h3>
<p>Git 并不会推断你输入的几个字符将会是哪条命令，不过如果想偷懒，少敲几个命令的字符，可以用 <code>git config</code> 为命令设置别名。来看看下面的例子：</p>
<pre><code><span class="variable">$ </span>git config --global <span class="keyword">alias</span>.co checkout
<span class="variable">$ </span>git config --global <span class="keyword">alias</span>.br branch
<span class="variable">$ </span>git config --global <span class="keyword">alias</span>.ci commit
<span class="variable">$ </span>git config --global <span class="keyword">alias</span>.st status
</code></pre><p>现在，如果要输入 <code>git commit</code> 只需键入 <code>git ci</code> 即可。而随着 Git 使用的深入，会有很多经常要用到的命令，遇到这种情况，不妨建个别名提高效率。</p>
<p>使用这种技术还可以创造出新的命令，比方说取消暂存文件时的输入比较繁琐，可以自己设置一下：</p>
<pre><code><span class="variable">$ </span>git config --global <span class="keyword">alias</span>.unstage <span class="string">'reset HEAD --'</span>
</code></pre><p>这样一来，下面的两条命令完全等同：</p>
<pre><code><span class="variable">$ </span>git unstage fileA
<span class="variable">$ </span>git reset <span class="constant">HEAD</span> fileA
</code></pre><p>显然，使用别名的方式看起来更清楚。另外，我们还经常设置 <code>last</code> 命令：</p>
<pre><code><span class="variable">$ </span>git config --global <span class="keyword">alias</span>.last <span class="string">'log -1 HEAD'</span>
</code></pre><p>然后要看最后一次的提交信息，就变得简单多了：</p>
<pre><code>$ git last
<span class="operator"><span class="keyword">commit</span> <span class="number">66938</span>dae3329c7aebe598c2246a8e6af90d04646
Author: Josh Goebel &lt;dreamer3@example.com&gt;
<span class="keyword">Date</span>:   Tue Aug <span class="number">26</span> <span class="number">19</span>:<span class="number">48</span>:<span class="number">51</span> <span class="number">2008</span> +<span class="number">0800</span>

    test <span class="keyword">for</span> <span class="keyword">current</span> head

    Signed-off-<span class="keyword">by</span>: Scott Chacon &lt;schacon@example.com&gt;</span>
</code></pre><p>可以看出，实际上 Git 只是简单地在命令中替换了你设置的别名。不过有时候我们希望运行某个外部命令，而非 Git 的子命令，这个好办，只需要在命令前加上 <code>!</code> 就行。如果你自己写了些处理 Git 仓库信息的脚本的话，就可以用这种技术包装起来。作为演示，我们可以设置用 <code>git visual</code> 启动 <code>gitk</code>：</p>
<pre><code><span class="variable">$ </span>git config --global <span class="keyword">alias</span>.visual <span class="string">'!gitk'</span>
</code></pre><hr>
<h2 id="小结">小结</h2>
<p>到目前为止，你已经学会了最基本的 Git 本地操作：创建和克隆仓库，做出修改，暂存并提交这些修改，以及查看所有历史修改记录。接下来，我们将学习 Git 的必杀技特性：分支模型。</p>
<hr>
<p>本书采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh" target="_blank">Creative Commons 署名-非商业性使用-相同方式共享 3.0 未本地化版本协议</a>发布。</p>
<p><a href="/progit/01-introduction">上一章</a> / <a href="/progit/03-git-branching">下一章</a> / <a href="/progit">返回</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ld.mmyz.net/progit/02-git-basics/index.html" data-id="z745ofbbnlw58qa3" class="article-share-link">分享</a>
      
      
      
      
      
<section id="comments">
<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Pro Git - 2. Git 基础" data-title="Pro Git - 2. Git 基础" data-url="http://ld.mmyz.net/progit/02-git-basics/index.html"></div>
<!--	<div class="ds-thread"></div> -->
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"cptsct"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- 多说公共JS代码 end -->
</section>


    </footer>
  </div>

  
    
  

</article>


</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
	<img src="/img/cptsct.png" alt="茂名市第一中学灵动计算机社社徽" style="border:0; border-radius:90px; height:180px; width:180px; padding: 0; margin: 10px auto 10px auto; display: block; box-shadow: 0 0 20px #999;" />
</div>

  
    <div class="widget-wrap">
	<h3 class="widget-title">灵动计算机社</h3>
	<div class="widget">
		<div>
			前世计协九八始 汇聚挚友茂一中<br />
			技术日新源于灵 能力提升寓于动<br />
			设计开发论精巧 管理操作各不同<br />
			信息科学有奥秘 与君一道乐其中<br />
		</div>
		<hr />
		
		QQ群: <a target="_blank" href="http://shang.qq.com/wpa/qunwpa?idkey=e365083a81eab47f1c53bfb6841ba8f926bad68e84b154c3252e42df5be72486">240696962</a><br />
		Email: <a href="&#x6d;&#97;&#x69;&#108;&#x74;&#111;&#x3a;&#x6d;&#x6d;&#121;&#122;&#99;&#112;&#x74;&#115;&#x63;&#x74;&#x40;&#49;&#50;&#x36;&#46;&#x63;&#x6f;&#109;">&#x6d;&#x6d;&#121;&#122;&#99;&#112;&#x74;&#115;&#x63;&#x74;&#x40;&#49;&#50;&#x36;&#46;&#x63;&#x6f;&#109;</a>
	</div>
</div>  

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/分享/">分享</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/工作/">工作</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/活动/">活动</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/规章/">规章</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 12.00px;">C</a><a href="/tags/Excel/" style="font-size: 10.00px;">Excel</a><a href="/tags/Git/" style="font-size: 10.00px;">Git</a><a href="/tags/IP/" style="font-size: 10.00px;">IP</a><a href="/tags/Linux/" style="font-size: 10.00px;">Linux</a><a href="/tags/Ps/" style="font-size: 20.00px;">Ps</a><a href="/tags/WiFi/" style="font-size: 10.00px;">WiFi</a><a href="/tags/Windows Tips/" style="font-size: 16.00px;">Windows Tips</a><a href="/tags/Word/" style="font-size: 10.00px;">Word</a><a href="/tags/多媒体/" style="font-size: 16.00px;">多媒体</a><a href="/tags/安全/" style="font-size: 10.00px;">安全</a><a href="/tags/招新/" style="font-size: 10.00px;">招新</a><a href="/tags/操作系统/" style="font-size: 10.00px;">操作系统</a><a href="/tags/新鲜玩意儿/" style="font-size: 14.00px;">新鲜玩意儿</a><a href="/tags/无线网络/" style="font-size: 10.00px;">无线网络</a><a href="/tags/比赛/" style="font-size: 12.00px;">比赛</a><a href="/tags/电脑小知识/" style="font-size: 18.00px;">电脑小知识</a><a href="/tags/硬件/" style="font-size: 10.00px;">硬件</a><a href="/tags/社团嘉年华/" style="font-size: 10.00px;">社团嘉年华</a><a href="/tags/社团文化节/" style="font-size: 12.00px;">社团文化节</a><a href="/tags/编程/" style="font-size: 10.00px;">编程</a><a href="/tags/网络/" style="font-size: 12.00px;">网络</a><a href="/tags/讲座/" style="font-size: 12.00px;">讲座</a><a href="/tags/语音室/" style="font-size: 10.00px;">语音室</a><a href="/tags/课程/" style="font-size: 16.00px;">课程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最近更新</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/06/coule_c_do_a_lot/">《学会了 C 语言真的可以开发出很多东西吗？》· 转自知乎</a>
          </li>
        
          <li>
            <a href="/2014/06/photoshop_contest_result/">Photoshop 平面设计大赛结果出来啦！</a>
          </li>
        
          <li>
            <a href="/2014/06/photoshop_contest/">“我爱一中”·Photoshop 平面设计大赛素材预览版放送</a>
          </li>
        
          <li>
            <a href="/2014/06/photoshop_lesson4/">Photoshop课程学习资料（第4节）</a>
          </li>
        
          <li>
            <a href="/2014/06/progit/">Pro Git 来了！</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    <div class="widget-wrap">
	<h3 class="widget-title">友情链接</h3>
	<div class="widget">
		<ul>
			<li><a href="http://mmyzjixie.blog.163.com/" title="曾经的计算机协会" target="_blank">茂名一中计协 - 网易博客</a></li>
			<li><a href="http://tieba.baidu.com/f?kw=%E8%8C%82%E5%90%8D%E5%B8%82%E7%AC%AC%E4%B8%80%E4%B8%AD%E5%AD%A6%E7%A4%BE%E5%9B%A2%E8%81%94%E5%90%88%E4%BC%9A" title="社联贴吧" target="_blank">茂名一中社团联合会 - 百度贴吧</a></li>
			<li><a href="http://www.ewics.net/" title="艺睿(E-WI)计算机社团" target="_blank">艺睿(E-WI)计算机社团</a></li>
		</ul>
	</div>
</div> 

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2014 茂名市第一中学灵动计算机社<br>
      Powered by <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a>, Hosted by <a href="https://gitcafe.com/" target="_blank">GitCafe</a>.
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
    <a href="/archives" class="mobile-nav-link">存档</a>
  
    <a href="http://www.mmyz.net/" class="mobile-nav-link">学校网站</a>
  
</nav>
    

<script src="/js/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script type="text/javascript" src="/js/script.js"></script>
  </div>
</body>
</html>